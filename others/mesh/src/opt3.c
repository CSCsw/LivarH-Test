#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <sys/resource.h>

#include "opt.h"
#include "fcn.h"
#include "pre.h"

#ifndef MICROSEC
#  define MICROSEC 1000000
#endif

#undef epsilonf
#define epsilonf 1.0e-10

/*****************************************************************************/
/* These functions are for obtaining the compacted vertex representation     */
/* of the mesh and for putting the compacted vectex representation back into */
/* the mesh structure.                                                       */
/*****************************************************************************/

static void scatterMesh(Mesh *m, const double *src) 
{
  /***************************************************************************/
  /* Take the src vertices and apply the inverse permutation to scatter the  */
  /* nonfixed coordinates into the mesh structure.                           */
  /***************************************************************************/

  double *v = m->v;
  int    *ip = m->i;

  const int nn = m->nn;
  int     i, loc;

  for (i = 0; i < nn; ++i) {
    loc = *ip++;
    v[loc  ] = src[0]; 
    v[loc+1] = src[1];
    v[loc+2] = src[2];
    src += 3;
  }
  return;
}

static void gatherMesh(double *dest, const Mesh *m)
{
  /***************************************************************************/
  /* Take the src vertices and apply the permutation to gather the nonfixed  */
  /* coordinates into the dest.                                              */
  /***************************************************************************/

  double *v = m->v;
  int    *ip = m->i;

  const int nn = m->nn;
  int     i, loc;

  for (i = 0; i < nn; ++i) {
    loc = *ip++;
    dest[0] = v[loc  ]; 
    dest[1] = v[loc+1];
    dest[2] = v[loc+2];
    dest += 3;
  }
  return;
}

/*****************************************************************************/
/* We now get into the code to the algorithm.  The first is a matrix vector  */
/* multiplication using the block structure.  This is in the reduced space.  */
/* We use pointer arithmetic to speed up the code generated by gcc.  Other   */
/* compilers would have done this automatically.                             */
/*****************************************************************************/

#if 1
static void matmul(double *w, const Mesh *mesh, const double *p)
{
  int    *len = mesh->len;
  int    *col = mesh->col;
  double *dat = mesh->dat;
  double *n;
  double *o;

  double x[3];
  double y[3];
  double m[3];

  const int nn = mesh->nn;
  int c;
  int i, j, l;

#if 0
  int r;
#endif

  for (i = 0; i < nn; ++i) {
    /* Get x components and modification for diagonal block */
    l = *len++;
    c = *col++;
    o = w + c;

    x[0] = p[c  ];
    x[1] = p[c+1];
    x[2] = p[c+2];

    m[0] = dat[0]*x[0] + dat[1]*x[1] + dat[2]*x[2];
    m[1] = dat[1]*x[0] + dat[3]*x[1] + dat[4]*x[2];
    m[2] = dat[2]*x[0] + dat[4]*x[1] + dat[5]*x[2];

#if 0
    r = c;
    printf("%d %d %20.19e\n", r+0, c+0, dat[0]);
    printf("%d %d %20.19e\n", r+0, c+1, dat[1]);
    printf("%d %d %20.19e\n", r+0, c+2, dat[2]);
    printf("%d %d %20.19e\n", r+1, c+0, dat[1]);
    printf("%d %d %20.19e\n", r+1, c+1, dat[3]);
    printf("%d %d %20.19e\n", r+1, c+2, dat[4]);
    printf("%d %d %20.19e\n", r+2, c+0, dat[2]);
    printf("%d %d %20.19e\n", r+2, c+1, dat[4]);
    printf("%d %d %20.19e\n", r+2, c+2, dat[5]);
#endif

    dat += 6;

    /* Calculate the off diagonal blocks */
    for (j = 1; j < l; ++j) {
      c = *col++;
      n = w + c;
     
      y[0] = p[c  ];
      y[1] = p[c+1];
      y[2] = p[c+2];

      n[0] += dat[0]*x[0] + dat[3]*x[1] + dat[6]*x[2];
      n[1] += dat[1]*x[0] + dat[4]*x[1] + dat[7]*x[2];
      n[2] += dat[2]*x[0] + dat[5]*x[1] + dat[8]*x[2];

      m[0] += dat[0]*y[0] + dat[1]*y[1] + dat[2]*y[2];
      m[1] += dat[3]*y[0] + dat[4]*y[1] + dat[5]*y[2];
      m[2] += dat[6]*y[0] + dat[7]*y[1] + dat[8]*y[2];

#if 0
      printf("%d %d %20.19e\n", r+0, c+0, dat[0]);
      printf("%d %d %20.19e\n", c+0, r+0, dat[0]);
      printf("%d %d %20.19e\n", r+0, c+1, dat[1]);
      printf("%d %d %20.19e\n", c+1, r+0, dat[1]);
      printf("%d %d %20.19e\n", r+0, c+2, dat[2]);
      printf("%d %d %20.19e\n", c+2, r+0, dat[2]);
      printf("%d %d %20.19e\n", r+1, c+0, dat[3]);
      printf("%d %d %20.19e\n", c+0, r+1, dat[3]);
      printf("%d %d %20.19e\n", r+1, c+1, dat[4]);
      printf("%d %d %20.19e\n", c+1, r+1, dat[4]);
      printf("%d %d %20.19e\n", r+1, c+2, dat[5]);
      printf("%d %d %20.19e\n", c+2, r+1, dat[5]);
      printf("%d %d %20.19e\n", r+2, c+0, dat[6]);
      printf("%d %d %20.19e\n", c+0, r+2, dat[6]);
      printf("%d %d %20.19e\n", r+2, c+1, dat[7]);
      printf("%d %d %20.19e\n", c+1, r+2, dat[7]);
      printf("%d %d %20.19e\n", r+2, c+2, dat[8]);
      printf("%d %d %20.19e\n", c+2, r+2, dat[8]);
#endif

      dat += 9;
    }

    /* Add modifiation */
    o[0] += m[0];
    o[1] += m[1];
    o[2] += m[2];
  }

#if 0
  exit(-1);
#endif
  return;
}

#else

#define CACHE_ELEMENTS 32
#define CACHE_SIZE      4

static void matmul(double *w, const Mesh *mesh, const double *p)
{
  int    *len = mesh->len;
  int    *col = mesh->col;
  double *dat = mesh->dat;
  double *n;
  double *o;

  int    cache_idx[CACHE_ELEMENTS];
  double cache_dat_x[CACHE_ELEMENTS*CACHE_SIZE];
#if 0
  double cache_dat_w[CACHE_ELEMENTS*CACHE_SIZE];
#endif

  double x[3];
  double y[3];
  double m[3];

  const int nn = mesh->nn;
  int c;
  int i, j, l;
  int idx;

  j = 0;
  l = 0;

  for (i = 0, j = 0, l = 0; i < CACHE_ELEMENTS; ++i, j += 4, l += 3) {
    cache_idx[i] = l;

    cache_dat_x[j  ] = p[l  ];
    cache_dat_x[j+1] = p[l+1];
    cache_dat_x[j+2] = p[l+2];

#if 0
    cache_dat_w[j  ] = 0.0;
    cache_dat_w[j+1] = 0.0;
    cache_dat_w[j+2] = 0.0;
#endif
  }

  for (i = 0; i < nn; ++i) {
    /* Get x components and modification for diagonal block */
    l = *len++;
    c = *col++;
    o = w + c;

    idx = c % CACHE_ELEMENTS;
    if (c == cache_idx[idx]) {
      idx *= CACHE_SIZE;
      x[0] = cache_dat_x[idx  ];
      x[1] = cache_dat_x[idx+1];
      x[2] = cache_dat_x[idx+2];
    } else
    {
      cache_idx[idx  ] = c;

      idx *= CACHE_SIZE;
      cache_dat_x[idx  ] = x[0] = p[c  ];
      cache_dat_x[idx+1] = x[1] = p[c+1];
      cache_dat_x[idx+2] = x[2] = p[c+2];
    }

    m[0] = dat[0]*x[0] + dat[1]*x[1] + dat[2]*x[2];
    m[1] = dat[1]*x[0] + dat[3]*x[1] + dat[4]*x[2];
    m[2] = dat[2]*x[0] + dat[4]*x[1] + dat[5]*x[2];

    dat += 6;

    /* Calculate the off diagonal blocks */
    for (j = 1; j < l; ++j) {
      c = *col++;
      n = w + c;
     
      idx = c % CACHE_ELEMENTS;
      if (c == cache_idx[idx]) {
	idx *= CACHE_SIZE;
        y[0] = cache_dat_x[idx  ];
        y[1] = cache_dat_x[idx+1];
        y[2] = cache_dat_x[idx+2];
      } else
      {
        cache_idx[idx  ] = c;

        idx *= CACHE_SIZE;
        cache_dat_x[idx  ] = y[0] = p[c  ];
        cache_dat_x[idx+1] = y[1] = p[c+1];
        cache_dat_x[idx+2] = y[2] = p[c+2];
      }

      n[0] += dat[0]*x[0] + dat[3]*x[1] + dat[6]*x[2];
      n[1] += dat[1]*x[0] + dat[4]*x[1] + dat[7]*x[2];
      n[2] += dat[2]*x[0] + dat[5]*x[1] + dat[8]*x[2];

      m[0] += dat[0]*y[0] + dat[1]*y[1] + dat[2]*y[2];
      m[1] += dat[3]*y[0] + dat[4]*y[1] + dat[5]*y[2];
      m[2] += dat[6]*y[0] + dat[7]*y[1] + dat[8]*y[2];

      dat += 9;
    }

    /* Add modifiation */
    o[0] += m[0];
    o[1] += m[1];
    o[2] += m[2];
  }
  return;
}
#endif

static double norm(const double *g, const int nn)
{
  double norm_r = 0;
  int    i;
     
  for (i = 0; i < nn; ++i) {
    norm_r += g[0]*g[0] + g[1]*g[1] + g[2]*g[2];
    g += 3;
  }
  return norm_r;
}

static double inner(const double *g, const double *w, const int nn)
{
  double inner_r = 0;
  int    i;
     
  for (i = 0; i < nn; ++i) {
    inner_r += g[0]*w[0] + g[1]*w[1] + g[2]*w[2];
    g += 3;
    w += 3;
  }
  return inner_r;
}

static void negatef(double *r, const double *g, const int nn)
{
  int i;

  for (i = 0; i < nn; ++i) {
    r[0] = -g[0];
    r[1] = -g[1];
    r[2] = -g[2];
    r += 3;
    g += 3;
  }
  return;
}

static void axpy(double *r, const double *x, const double c, const double *y, 
		 const int nn)
{
  int i;

  for (i = 0; i < nn; ++i) {
    r[0] = x[0] + c*y[0];
    r[1] = x[1] + c*y[1];
    r[2] = x[2] + c*y[2];
    r += 3;
    x += 3;
    y += 3;
  }

  return;
}

int optMesh(Mesh *mesh, double cn_tol, int precond)
{
  const double cg_tol = 1e-2;
  const double sigma  = 1e-4;
  const double beta0  = 0.25;
  const double beta1  = 0.80;
  const double tol1   = 1e-8;
  const int max_iter  = 500;
  const int max_cg_iter = 100;

  Precond  *prec;

  double *v;
  double *w;
  double *z;
  double *d;
  double *p;
  double *r;
  double *t;

  double norm_r, norm_g;
  double alpha, beta;
  double rzm1, rzm2;
  double obj, objn;

  const int nn = mesh->nn;
  int iter = 0, cg_iter;
  int nf = 1, ng = 1, nh = 0;
  int ferr;

  double m, m1, m2;
  double s, s1, s2;
  double t1, t2;

  struct rusage r0, r1;

#ifdef DISPLAY_MAX
  double fmax;
  int    fidx;
#endif

  if (nn <= 0) {
    /* No nodes!  Just return.                                               */
    return 0;
  }

  getrusage(RUSAGE_SELF, &r0);

  hMesh(mesh);
  if (gFcn(&obj, mesh)) {
    fprintf(stderr, "Invalid starting point.\n");
    exit(-1);
  }

  prec = preCreate(precond, nn, mesh->nz);

  v  = (double *)malloc(3*sizeof(double)*nn);
  w  = (double *)malloc(3*sizeof(double)*nn);
  z  = (double *)malloc(3*sizeof(double)*nn);
  d  = (double *)malloc(3*sizeof(double)*nn);
  p  = (double *)malloc(3*sizeof(double)*nn);
  r  = (double *)malloc(3*sizeof(double)*nn);

  gatherMesh(v, mesh);
  norm_r = norm(mesh->g, nn);
  norm_g = sqrt(norm_r);

  getrusage(RUSAGE_SELF, &r1);

  m1 = (double) r1.ru_utime.tv_usec;
  m2 = (double) r0.ru_utime.tv_usec;
  m = m1 - m2;
    
  s1 = (double) r1.ru_utime.tv_sec;
  s2 = (double) r0.ru_utime.tv_sec;
  s = s1 - s2;

  t1 = s + m / MICROSEC;

  m1 = (double) r1.ru_stime.tv_usec;
  m2 = (double) r0.ru_stime.tv_usec;
  m = m1 - m2;

  s1 = (double) r1.ru_stime.tv_sec;
  s2 = (double) r0.ru_stime.tv_sec;
  s = s1 - s2;

  t2 = s + m / MICROSEC;

#ifdef DISPLAY_MAX
  oMax(&fmax, &fidx, mesh);
  printf("%4d I      %10.9e %5.4e            %5.4e %5d "
         "usr: %5.4e sys: %5.4e tot: %5.4e\n",
         iter, obj, norm_g, fmax, fidx, t1, t2, t1+t2);
#else
  printf("%4d I      %10.9e %5.4e            "
         "usr: %5.4e sys: %5.4e tot: %5.4e\n",
         iter, obj, norm_g, t1, t2, t1+t2);
#endif

  while ((norm_g > cn_tol) && (iter < max_iter)) {
    getrusage(RUSAGE_SELF, &r0);
    ++iter;

    ++nh;
    hOnly(mesh);
    tryADOLC(mesh,nh);
    prec->calc(prec, mesh);

    memset(d, 0, 3*sizeof(double)*nn);
    negatef(r, mesh->g, nn);
    norm_g *= cg_tol;

    prec->apply(z, r, prec, mesh);
    memcpy(p, z, 3*sizeof(double)*nn);
    rzm1 = inner(z, r, nn);

    cg_iter = 0;
    while ((sqrt(norm_r) > norm_g) && (cg_iter < max_cg_iter)) {
      ++cg_iter;

      memset(w, 0, 3*sizeof(double)*nn);
      matmul(w, mesh, p);

      alpha = inner(p, w, nn);
      if (alpha <= 0.0) {
	printf("Direction of Negative Curvature\n");
        if (1 == cg_iter) {
          axpy(d, d, 1.0, p, nn);
        }
	break;
      }

      alpha = rzm1 / alpha;

      axpy(d, d,  alpha, p, nn);
      axpy(r, r, -alpha, w, nn);
      norm_r = norm(r, nn);

      prec->apply(z, r, prec, mesh);

      rzm2 = rzm1;
      rzm1 = inner(z, r, nn);
      beta = rzm1 / rzm2;
      axpy(p, z, beta, p, nn);
    }

    alpha = inner(mesh->g, d, nn);
    if (alpha > 0.0) {
      printf("Not descent.\n");
      exit(-1);
    }
    else {
      alpha *= sigma;
    }
    beta = 1.0;

    /* Unrolled for better performance.  Only do a gradient evaluation when  */
    /* beta = 1.0.  Do not do this at other times.                           */

    axpy(w, v, beta, d, nn);
    scatterMesh(mesh, w);

    ++nf;
    ++ng;
    ferr = gFcn(&objn, mesh);

    if ((!ferr && (obj - objn >= -alpha*beta - epsilonf)) ||
	(!ferr && (sqrt(norm(mesh->g, nn)) < 100*cn_tol))) {
      /* Iterate is acceptable */
    }
    else {
      if (ferr) {
	/* Function not defined at trial point */
	beta *= beta0;
      }
      else {
	/* Iterate not acceptable */
	beta *= beta1;
      }

      while (beta >= tol1) {
        axpy(w, v, beta, d, nn);
        scatterMesh(mesh, w);

        ++nf;
        if (oFcn(&objn, mesh)) {
	  /* Function not defined at trial point */
	  beta *= beta0;
        }
        else if (obj - objn >= -alpha*beta - epsilonf) {
	  /* Iterate is acceptable */
	  break;
        }
        else {
	  /* Iterate not acceptable */
	  beta *= beta1;
        }
      }

      if (beta < tol1) {
        printf("Newton step not good\n");
        exit(-1);
      }

      ++ng;
      gOnly(mesh);
    }

    /* Update the iterate (v = current point, w = new point) so swap */
    t = v;
    v = w;
    w = t;

    obj = objn;
    norm_r = norm(mesh->g, nn);
    norm_g = sqrt(norm_r);

    getrusage(RUSAGE_SELF, &r1);

    m1 = (double) r1.ru_utime.tv_usec;
    m2 = (double) r0.ru_utime.tv_usec;
    m = m1 - m2;
    
    s1 = (double) r1.ru_utime.tv_sec;
    s2 = (double) r0.ru_utime.tv_sec;
    s = s1 - s2;
    
    t1 = s + m / MICROSEC;
    
    m1 = (double) r1.ru_stime.tv_usec;
    m2 = (double) r0.ru_stime.tv_usec;
    m = m1 - m2;
    
    s1 = (double) r1.ru_stime.tv_sec;
    s2 = (double) r0.ru_stime.tv_sec;
    s = s1 - s2;
    
    t2 = s + m / MICROSEC;
    
#ifdef DISPLAY_MAX
    oMax(&fmax, &fidx, mesh);
    printf("%4d N %4d %10.9e %5.4e %5.4e %5.4e %5d "
           "usr: %5.4e sys: %5.4e tot: %5.4e\n",
           iter, cg_iter, obj, norm_g, beta, fmax, fidx, t1, t2, t1+t2);
#else
    printf("%4d N %4d %10.9e %5.4e %5.4e usr: %5.4e sys: %5.4e tot: %5.4e\n",
           iter, cg_iter, obj, norm_g, beta, t1, t2, t1+t2);
#endif
  }

  printf("Function evals: %4d\nGradient evals: %4d\nHessian  evals: %4d\n", 
	 nf, ng, nh);

  prec->destroy(prec);

  free(v);
  free(w);
  free(z);
  free(d);
  free(p);
  free(r);
  return 0;
}
